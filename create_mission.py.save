import numpy as np
from fastkml import kml
from shapely.geometry import Polygon, box
from dronekit import Command
from pymavlink import mavutil
import os

# --- STEP 0: Configuration - MODIFY THESE VALUES ---

# 1. INPUT KML FILE
# The path to the KML file that defines the survey area.
KML_FILE_PATH = 'plot.kml'

# 2. FLIGHT PARAMETERS
# The altitude at which the drone will fly the mission.
FLIGHT_ALTITUDE_METERS = 30
# The desired overlap between adjacent flight lines (e.g., 40 for 40%).
# This helps ensure there are no gaps in your video coverage.
SIDELAP_PERCENTAGE = 40
# The desired width of each rectangular scanning area in degrees.
# A smaller value creates smaller, more numerous rectangles.
# For a 2-acre plot, a value between 0.0003 and 0.0008 is a good starting point.
# Adjust this based on your drone's battery life and desired video file size.
RECTANGLE_WIDTH_DEG = 0.0005

# 3. OUTPUT FILE
# The name of the file where the generated mission waypoints will be saved.
OUTPUT_MISSION_FILE = 'drone_mission.txt'

# --- Main Functions (No need to modify below this line) ---

def create_dummy_kml(filename='plot.kml'):
    """Creates a sample KML file for testing if one doesn't exist."""
    if not os.path.exists(filename):
        print(f"'{filename}' not found. Creating a dummy KML for demonstration.")
        k = kml.KML()
        ns = '{http://www.opengis.net/kml/2.2}'
        d = kml.Document(ns, 'docid', 'Survey Area', 'A sample plot for testing')
        p = kml.Placemark(ns, 'pmid', 'Plot', 'Sample 2-acre plot')
        p.geometry = Polygon([
            (-74.0064, 40.7128), 
            (-74.0050, 40.7138), 
            (-74.0040, 40.7125),
            (-74.0054, 40.7115),
            (-74.0064, 40.7128)
        ])
        d.append(p)
        k.append(d)
        with open(filename, 'w') as kml_file:
            kml_file.write(k.to_string(prettyprint=True))

def parse_polygon_from_kml(kml_file):
    """Parses a KML file and extracts the first polygon found."""
    k = kml.KML()
    with open(kml_file, 'rt', encoding='utf-8') as f:
        k.from_string(f.read())

    # Find the first Placemark with a Polygon
    for feature in k.features():
        if isinstance(feature, kml.Document):
            for doc_feature in feature.features():
                 if isinstance(doc_feature, kml.Placemark) and isinstance(doc_feature.geometry, Polygon):
                    return doc_feature.geometry
    raise ValueError("No Polygon found in the KML file.")

def create_survey_grid(polygon, rect_width):
    """Divides a polygon into a grid of smaller rectangular survey areas."""
    min_lon, min_lat, max_lon, max_lat = polygon.bounds
    rect_height = rect_width  # Use square grid cells for simplicity
    survey_rects = []

    lon = min_lon
    while lon < max_lon:
        lat = min_lat
        while lat < max_lat:
            grid_cell = box(lon, lat, lon + rect_width, lat + rect_height)
            # Only include cells that are inside the main plot polygon
            if polygon.intersects(grid_cell):
                survey_rects.append(grid_cell.intersection(polygon))
            lat += rect_height
        lon += rect_width
        
    return survey_rects

def generate_lawnmower_path(rectangle, altitude, sidelap):
    """Generates a serpentine (lawnmower) path within a rectangular area."""
    min_lon, min_lat, max_lon, max_lat = rectangle.bounds
    waypoints = []
    
    # Calculate the distance between scan lines based on sidelap
    # A more precise calculation would involve camera's field-of-view (FOV)
    scan_line_separation = (max_lat - min_lat) * (1 - sidelap / 100.0)
    if scan_line_separation <= 0: return []

    current_lon = min_lon
    direction = 1  # 1 for flying South to North, -1 for North to South

    while current_lon <= max_lon:
        if direction == 1:
            waypoints.append((min_lat, current_lon, altitude))
            waypoints.append((max_lat, current_lon, altitude))
        else:
            waypoints.append((max_lat, current_lon, altitude))
            waypoints.append((min_lat, current_lon, altitude))
        
        current_lon += scan_line_separation
        direction *= -1

    return waypoints

def save_mission_to_file(waypoints, filename):
    """Saves the list of waypoints to a MAVLink-compatible text file."""
    with open(filename, 'w') as f:
        f.write('QGC WPL 110\n') # File header for QGroundControl compatibility
        # Home position (can be set to the first waypoint)
        f.write(f'0\t1\t0\t16\t0\t0\t0\t0\t{waypoints[0][0]}\t{waypoints[0][1]}\t{waypoints[0][2]}\t1\n')
        
        for i, (lat, lon, alt) in enumerate(waypoints):
            # MAV_CMD_NAV_WAYPOINT format:
            # SEQ, CURRENT, FRAME, CMD, PARAM1-4, LAT, LON, ALT, AUTOCONTINUE
            f.write(f'{i+1}\t0\t3\t16\t0\t0\t0\t0\t{lat}\t{lon}\t{alt}\t1\n')
    print(f"\n✅ Mission successfully saved to '{filename}'")

def main():
    """Main function to execute the script."""
    print("--- Drone Survey Mission Planner ---")
    
    # Create a dummy KML if the specified one doesn't exist
    create_dummy_kml(KML_FILE_PATH)
    
    # 1. Parse KML
    print(f"\n1. Parsing KML file: '{KML_FILE_PATH}'...")
    plot_polygon = parse_polygon_from_kml(KML_FILE_PATH)
    print("   Polygon extracted successfully.")
    
    # 2. Create Grid
    print("\n2. Splitting plot into rectangular survey areas...")
    survey_areas = create_survey_grid(plot_polygon, RECTANGLE_WIDTH_DEG)
    print(f"   Plot divided into {len(survey_areas)} rectangular cells.")
    
    # 3. Generate Waypoints
    print("\n3. Generating lawnmower waypoints for each cell...")
    all_waypoints = []
    for area in survey_areas:
        path = generate_lawnmower_path(area, FLIGHT_ALTITUDE_METERS, SIDELAP_PERCENTAGE)
        all_waypoints.extend(path)
    print(f"   Generated a total of {len(all_waypoints)} waypoints.")
    
    # 4. Save Mission
    if not all_waypoints:
        print("\n❌ No waypoints were generated. Check your configuration.")
        return
        
    print(f"\n4. Saving mission to file: '{OUTPUT_MISSION_FILE}'...")
    save_mission_to_file
